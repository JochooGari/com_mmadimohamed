"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getInstanceCacheStatistics = getInstanceCacheStatistics;
exports.getInstanceCacheMetrics = getInstanceCacheMetrics;
exports.clearInstanceCache = clearInstanceCache;
exports.getN8nApiClient = getN8nApiClient;
exports.handleCreateWorkflow = handleCreateWorkflow;
exports.handleGetWorkflow = handleGetWorkflow;
exports.handleGetWorkflowDetails = handleGetWorkflowDetails;
exports.handleGetWorkflowStructure = handleGetWorkflowStructure;
exports.handleGetWorkflowMinimal = handleGetWorkflowMinimal;
exports.handleUpdateWorkflow = handleUpdateWorkflow;
exports.handleDeleteWorkflow = handleDeleteWorkflow;
exports.handleListWorkflows = handleListWorkflows;
exports.handleValidateWorkflow = handleValidateWorkflow;
exports.handleAutofixWorkflow = handleAutofixWorkflow;
exports.handleTriggerWebhookWorkflow = handleTriggerWebhookWorkflow;
exports.handleGetExecution = handleGetExecution;
exports.handleListExecutions = handleListExecutions;
exports.handleDeleteExecution = handleDeleteExecution;
exports.handleHealthCheck = handleHealthCheck;
exports.handleListAvailableTools = handleListAvailableTools;
exports.handleDiagnostic = handleDiagnostic;
const n8n_api_client_1 = require("../services/n8n-api-client");
const n8n_api_1 = require("../config/n8n-api");
const n8n_api_2 = require("../types/n8n-api");
const n8n_validation_1 = require("../services/n8n-validation");
const n8n_errors_1 = require("../utils/n8n-errors");
const logger_1 = require("../utils/logger");
const zod_1 = require("zod");
const workflow_validator_1 = require("../services/workflow-validator");
const enhanced_config_validator_1 = require("../services/enhanced-config-validator");
const instance_context_1 = require("../types/instance-context");
const workflow_auto_fixer_1 = require("../services/workflow-auto-fixer");
const expression_format_validator_1 = require("../services/expression-format-validator");
const handlers_workflow_diff_1 = require("./handlers-workflow-diff");
const cache_utils_1 = require("../utils/cache-utils");
let defaultApiClient = null;
let lastDefaultConfigUrl = null;
const cacheMutex = new cache_utils_1.CacheMutex();
const instanceClients = (0, cache_utils_1.createInstanceCache)((client, key) => {
    logger_1.logger.debug('Evicting API client from cache', {
        cacheKey: key.substring(0, 8) + '...'
    });
});
function getInstanceCacheStatistics() {
    return (0, cache_utils_1.getCacheStatistics)();
}
function getInstanceCacheMetrics() {
    return cache_utils_1.cacheMetrics.getMetrics();
}
function clearInstanceCache() {
    instanceClients.clear();
    cache_utils_1.cacheMetrics.recordClear();
    cache_utils_1.cacheMetrics.updateSize(0, instanceClients.max);
}
function getN8nApiClient(context) {
    if (context?.n8nApiUrl && context?.n8nApiKey) {
        const validation = (0, instance_context_1.validateInstanceContext)(context);
        if (!validation.valid) {
            logger_1.logger.warn('Invalid instance context provided', {
                instanceId: context.instanceId,
                errors: validation.errors
            });
            return null;
        }
        const cacheKey = (0, cache_utils_1.createCacheKey)(`${context.n8nApiUrl}:${context.n8nApiKey}:${context.instanceId || ''}`);
        if (instanceClients.has(cacheKey)) {
            cache_utils_1.cacheMetrics.recordHit();
            return instanceClients.get(cacheKey) || null;
        }
        cache_utils_1.cacheMetrics.recordMiss();
        if (cacheMutex.isLocked(cacheKey)) {
            const waitTime = 100;
            const start = Date.now();
            while (cacheMutex.isLocked(cacheKey) && (Date.now() - start) < 1000) {
            }
            if (instanceClients.has(cacheKey)) {
                cache_utils_1.cacheMetrics.recordHit();
                return instanceClients.get(cacheKey) || null;
            }
        }
        const config = (0, n8n_api_1.getN8nApiConfigFromContext)(context);
        if (config) {
            logger_1.logger.info('Creating instance-specific n8n API client', {
                url: config.baseUrl.replace(/^(https?:\/\/[^\/]+).*/, '$1'),
                instanceId: context.instanceId,
                cacheKey: cacheKey.substring(0, 8) + '...'
            });
            const client = new n8n_api_client_1.N8nApiClient(config);
            instanceClients.set(cacheKey, client);
            cache_utils_1.cacheMetrics.recordSet();
            cache_utils_1.cacheMetrics.updateSize(instanceClients.size, instanceClients.max);
            return client;
        }
        return null;
    }
    logger_1.logger.info('Falling back to environment configuration for n8n API client');
    const config = (0, n8n_api_1.getN8nApiConfig)();
    if (!config) {
        if (defaultApiClient) {
            logger_1.logger.info('n8n API configuration removed, clearing default client');
            defaultApiClient = null;
            lastDefaultConfigUrl = null;
        }
        return null;
    }
    if (!defaultApiClient || lastDefaultConfigUrl !== config.baseUrl) {
        logger_1.logger.info('n8n API client initialized from environment', { url: config.baseUrl });
        defaultApiClient = new n8n_api_client_1.N8nApiClient(config);
        lastDefaultConfigUrl = config.baseUrl;
    }
    return defaultApiClient;
}
function ensureApiConfigured(context) {
    const client = getN8nApiClient(context);
    if (!client) {
        if (context?.instanceId) {
            throw new Error(`n8n API not configured for instance ${context.instanceId}. Please provide n8nApiUrl and n8nApiKey in the instance context.`);
        }
        throw new Error('n8n API not configured. Please set N8N_API_URL and N8N_API_KEY environment variables.');
    }
    return client;
}
const createWorkflowSchema = zod_1.z.object({
    name: zod_1.z.string(),
    nodes: zod_1.z.array(zod_1.z.any()),
    connections: zod_1.z.record(zod_1.z.any()),
    settings: zod_1.z.object({
        executionOrder: zod_1.z.enum(['v0', 'v1']).optional(),
        timezone: zod_1.z.string().optional(),
        saveDataErrorExecution: zod_1.z.enum(['all', 'none']).optional(),
        saveDataSuccessExecution: zod_1.z.enum(['all', 'none']).optional(),
        saveManualExecutions: zod_1.z.boolean().optional(),
        saveExecutionProgress: zod_1.z.boolean().optional(),
        executionTimeout: zod_1.z.number().optional(),
        errorWorkflow: zod_1.z.string().optional(),
    }).optional(),
});
const updateWorkflowSchema = zod_1.z.object({
    id: zod_1.z.string(),
    name: zod_1.z.string().optional(),
    nodes: zod_1.z.array(zod_1.z.any()).optional(),
    connections: zod_1.z.record(zod_1.z.any()).optional(),
    settings: zod_1.z.any().optional(),
});
const listWorkflowsSchema = zod_1.z.object({
    limit: zod_1.z.number().min(1).max(100).optional(),
    cursor: zod_1.z.string().optional(),
    active: zod_1.z.boolean().optional(),
    tags: zod_1.z.array(zod_1.z.string()).optional(),
    projectId: zod_1.z.string().optional(),
    excludePinnedData: zod_1.z.boolean().optional(),
});
const validateWorkflowSchema = zod_1.z.object({
    id: zod_1.z.string(),
    options: zod_1.z.object({
        validateNodes: zod_1.z.boolean().optional(),
        validateConnections: zod_1.z.boolean().optional(),
        validateExpressions: zod_1.z.boolean().optional(),
        profile: zod_1.z.enum(['minimal', 'runtime', 'ai-friendly', 'strict']).optional(),
    }).optional(),
});
const autofixWorkflowSchema = zod_1.z.object({
    id: zod_1.z.string(),
    applyFixes: zod_1.z.boolean().optional().default(false),
    fixTypes: zod_1.z.array(zod_1.z.enum([
        'expression-format',
        'typeversion-correction',
        'error-output-config',
        'node-type-correction',
        'webhook-missing-path'
    ])).optional(),
    confidenceThreshold: zod_1.z.enum(['high', 'medium', 'low']).optional().default('medium'),
    maxFixes: zod_1.z.number().optional().default(50)
});
const triggerWebhookSchema = zod_1.z.object({
    webhookUrl: zod_1.z.string().url(),
    httpMethod: zod_1.z.enum(['GET', 'POST', 'PUT', 'DELETE']).optional(),
    data: zod_1.z.record(zod_1.z.unknown()).optional(),
    headers: zod_1.z.record(zod_1.z.string()).optional(),
    waitForResponse: zod_1.z.boolean().optional(),
});
const listExecutionsSchema = zod_1.z.object({
    limit: zod_1.z.number().min(1).max(100).optional(),
    cursor: zod_1.z.string().optional(),
    workflowId: zod_1.z.string().optional(),
    projectId: zod_1.z.string().optional(),
    status: zod_1.z.enum(['success', 'error', 'waiting']).optional(),
    includeData: zod_1.z.boolean().optional(),
});
async function handleCreateWorkflow(args, context) {
    try {
        const client = ensureApiConfigured(context);
        const input = createWorkflowSchema.parse(args);
        const errors = (0, n8n_validation_1.validateWorkflowStructure)(input);
        if (errors.length > 0) {
            return {
                success: false,
                error: 'Workflow validation failed',
                details: { errors }
            };
        }
        const workflow = await client.createWorkflow(input);
        return {
            success: true,
            data: workflow,
            message: `Workflow "${workflow.name}" created successfully with ID: ${workflow.id}`
        };
    }
    catch (error) {
        if (error instanceof zod_1.z.ZodError) {
            return {
                success: false,
                error: 'Invalid input',
                details: { errors: error.errors }
            };
        }
        if (error instanceof n8n_errors_1.N8nApiError) {
            return {
                success: false,
                error: (0, n8n_errors_1.getUserFriendlyErrorMessage)(error),
                code: error.code,
                details: error.details
            };
        }
        return {
            success: false,
            error: error instanceof Error ? error.message : 'Unknown error occurred'
        };
    }
}
async function handleGetWorkflow(args, context) {
    try {
        const client = ensureApiConfigured(context);
        const { id } = zod_1.z.object({ id: zod_1.z.string() }).parse(args);
        const workflow = await client.getWorkflow(id);
        return {
            success: true,
            data: workflow
        };
    }
    catch (error) {
        if (error instanceof zod_1.z.ZodError) {
            return {
                success: false,
                error: 'Invalid input',
                details: { errors: error.errors }
            };
        }
        if (error instanceof n8n_errors_1.N8nApiError) {
            return {
                success: false,
                error: (0, n8n_errors_1.getUserFriendlyErrorMessage)(error),
                code: error.code
            };
        }
        return {
            success: false,
            error: error instanceof Error ? error.message : 'Unknown error occurred'
        };
    }
}
async function handleGetWorkflowDetails(args, context) {
    try {
        const client = ensureApiConfigured(context);
        const { id } = zod_1.z.object({ id: zod_1.z.string() }).parse(args);
        const workflow = await client.getWorkflow(id);
        const executions = await client.listExecutions({
            workflowId: id,
            limit: 10
        });
        const stats = {
            totalExecutions: executions.data.length,
            successCount: executions.data.filter(e => e.status === n8n_api_2.ExecutionStatus.SUCCESS).length,
            errorCount: executions.data.filter(e => e.status === n8n_api_2.ExecutionStatus.ERROR).length,
            lastExecutionTime: executions.data[0]?.startedAt || null
        };
        return {
            success: true,
            data: {
                workflow,
                executionStats: stats,
                hasWebhookTrigger: (0, n8n_validation_1.hasWebhookTrigger)(workflow),
                webhookPath: (0, n8n_validation_1.getWebhookUrl)(workflow)
            }
        };
    }
    catch (error) {
        if (error instanceof zod_1.z.ZodError) {
            return {
                success: false,
                error: 'Invalid input',
                details: { errors: error.errors }
            };
        }
        if (error instanceof n8n_errors_1.N8nApiError) {
            return {
                success: false,
                error: (0, n8n_errors_1.getUserFriendlyErrorMessage)(error),
                code: error.code
            };
        }
        return {
            success: false,
            error: error instanceof Error ? error.message : 'Unknown error occurred'
        };
    }
}
async function handleGetWorkflowStructure(args, context) {
    try {
        const client = ensureApiConfigured(context);
        const { id } = zod_1.z.object({ id: zod_1.z.string() }).parse(args);
        const workflow = await client.getWorkflow(id);
        const simplifiedNodes = workflow.nodes.map(node => ({
            id: node.id,
            name: node.name,
            type: node.type,
            position: node.position,
            disabled: node.disabled || false
        }));
        return {
            success: true,
            data: {
                id: workflow.id,
                name: workflow.name,
                active: workflow.active,
                isArchived: workflow.isArchived,
                nodes: simplifiedNodes,
                connections: workflow.connections,
                nodeCount: workflow.nodes.length,
                connectionCount: Object.keys(workflow.connections).length
            }
        };
    }
    catch (error) {
        if (error instanceof zod_1.z.ZodError) {
            return {
                success: false,
                error: 'Invalid input',
                details: { errors: error.errors }
            };
        }
        if (error instanceof n8n_errors_1.N8nApiError) {
            return {
                success: false,
                error: (0, n8n_errors_1.getUserFriendlyErrorMessage)(error),
                code: error.code
            };
        }
        return {
            success: false,
            error: error instanceof Error ? error.message : 'Unknown error occurred'
        };
    }
}
async function handleGetWorkflowMinimal(args, context) {
    try {
        const client = ensureApiConfigured(context);
        const { id } = zod_1.z.object({ id: zod_1.z.string() }).parse(args);
        const workflow = await client.getWorkflow(id);
        return {
            success: true,
            data: {
                id: workflow.id,
                name: workflow.name,
                active: workflow.active,
                isArchived: workflow.isArchived,
                tags: workflow.tags || [],
                createdAt: workflow.createdAt,
                updatedAt: workflow.updatedAt
            }
        };
    }
    catch (error) {
        if (error instanceof zod_1.z.ZodError) {
            return {
                success: false,
                error: 'Invalid input',
                details: { errors: error.errors }
            };
        }
        if (error instanceof n8n_errors_1.N8nApiError) {
            return {
                success: false,
                error: (0, n8n_errors_1.getUserFriendlyErrorMessage)(error),
                code: error.code
            };
        }
        return {
            success: false,
            error: error instanceof Error ? error.message : 'Unknown error occurred'
        };
    }
}
async function handleUpdateWorkflow(args, context) {
    try {
        const client = ensureApiConfigured(context);
        const input = updateWorkflowSchema.parse(args);
        const { id, ...updateData } = input;
        if (updateData.nodes || updateData.connections) {
            let fullWorkflow = updateData;
            if (!updateData.nodes || !updateData.connections) {
                const current = await client.getWorkflow(id);
                fullWorkflow = {
                    ...current,
                    ...updateData
                };
            }
            const errors = (0, n8n_validation_1.validateWorkflowStructure)(fullWorkflow);
            if (errors.length > 0) {
                return {
                    success: false,
                    error: 'Workflow validation failed',
                    details: { errors }
                };
            }
        }
        const workflow = await client.updateWorkflow(id, updateData);
        return {
            success: true,
            data: workflow,
            message: `Workflow "${workflow.name}" updated successfully`
        };
    }
    catch (error) {
        if (error instanceof zod_1.z.ZodError) {
            return {
                success: false,
                error: 'Invalid input',
                details: { errors: error.errors }
            };
        }
        if (error instanceof n8n_errors_1.N8nApiError) {
            return {
                success: false,
                error: (0, n8n_errors_1.getUserFriendlyErrorMessage)(error),
                code: error.code,
                details: error.details
            };
        }
        return {
            success: false,
            error: error instanceof Error ? error.message : 'Unknown error occurred'
        };
    }
}
async function handleDeleteWorkflow(args, context) {
    try {
        const client = ensureApiConfigured(context);
        const { id } = zod_1.z.object({ id: zod_1.z.string() }).parse(args);
        await client.deleteWorkflow(id);
        return {
            success: true,
            message: `Workflow ${id} deleted successfully`
        };
    }
    catch (error) {
        if (error instanceof zod_1.z.ZodError) {
            return {
                success: false,
                error: 'Invalid input',
                details: { errors: error.errors }
            };
        }
        if (error instanceof n8n_errors_1.N8nApiError) {
            return {
                success: false,
                error: (0, n8n_errors_1.getUserFriendlyErrorMessage)(error),
                code: error.code
            };
        }
        return {
            success: false,
            error: error instanceof Error ? error.message : 'Unknown error occurred'
        };
    }
}
async function handleListWorkflows(args, context) {
    try {
        const client = ensureApiConfigured(context);
        const input = listWorkflowsSchema.parse(args || {});
        const response = await client.listWorkflows({
            limit: input.limit || 100,
            cursor: input.cursor,
            active: input.active,
            tags: input.tags,
            projectId: input.projectId,
            excludePinnedData: input.excludePinnedData ?? true
        });
        const minimalWorkflows = response.data.map(workflow => ({
            id: workflow.id,
            name: workflow.name,
            active: workflow.active,
            isArchived: workflow.isArchived,
            createdAt: workflow.createdAt,
            updatedAt: workflow.updatedAt,
            tags: workflow.tags || [],
            nodeCount: workflow.nodes?.length || 0
        }));
        return {
            success: true,
            data: {
                workflows: minimalWorkflows,
                returned: minimalWorkflows.length,
                nextCursor: response.nextCursor,
                hasMore: !!response.nextCursor,
                ...(response.nextCursor ? {
                    _note: "More workflows available. Use cursor to get next page."
                } : {})
            }
        };
    }
    catch (error) {
        if (error instanceof zod_1.z.ZodError) {
            return {
                success: false,
                error: 'Invalid input',
                details: { errors: error.errors }
            };
        }
        if (error instanceof n8n_errors_1.N8nApiError) {
            return {
                success: false,
                error: (0, n8n_errors_1.getUserFriendlyErrorMessage)(error),
                code: error.code
            };
        }
        return {
            success: false,
            error: error instanceof Error ? error.message : 'Unknown error occurred'
        };
    }
}
async function handleValidateWorkflow(args, repository, context) {
    try {
        const client = ensureApiConfigured(context);
        const input = validateWorkflowSchema.parse(args);
        const workflowResponse = await handleGetWorkflow({ id: input.id });
        if (!workflowResponse.success) {
            return workflowResponse;
        }
        const workflow = workflowResponse.data;
        const validator = new workflow_validator_1.WorkflowValidator(repository, enhanced_config_validator_1.EnhancedConfigValidator);
        const validationResult = await validator.validateWorkflow(workflow, input.options);
        const response = {
            valid: validationResult.valid,
            workflowId: workflow.id,
            workflowName: workflow.name,
            summary: {
                totalNodes: validationResult.statistics.totalNodes,
                enabledNodes: validationResult.statistics.enabledNodes,
                triggerNodes: validationResult.statistics.triggerNodes,
                validConnections: validationResult.statistics.validConnections,
                invalidConnections: validationResult.statistics.invalidConnections,
                expressionsValidated: validationResult.statistics.expressionsValidated,
                errorCount: validationResult.errors.length,
                warningCount: validationResult.warnings.length
            }
        };
        if (validationResult.errors.length > 0) {
            response.errors = validationResult.errors.map(e => ({
                node: e.nodeName || 'workflow',
                message: e.message,
                details: e.details
            }));
        }
        if (validationResult.warnings.length > 0) {
            response.warnings = validationResult.warnings.map(w => ({
                node: w.nodeName || 'workflow',
                message: w.message,
                details: w.details
            }));
        }
        if (validationResult.suggestions.length > 0) {
            response.suggestions = validationResult.suggestions;
        }
        return {
            success: true,
            data: response
        };
    }
    catch (error) {
        if (error instanceof zod_1.z.ZodError) {
            return {
                success: false,
                error: 'Invalid input',
                details: { errors: error.errors }
            };
        }
        if (error instanceof n8n_errors_1.N8nApiError) {
            return {
                success: false,
                error: (0, n8n_errors_1.getUserFriendlyErrorMessage)(error),
                code: error.code
            };
        }
        return {
            success: false,
            error: error instanceof Error ? error.message : 'Unknown error occurred'
        };
    }
}
async function handleAutofixWorkflow(args, repository, context) {
    try {
        const client = ensureApiConfigured(context);
        const input = autofixWorkflowSchema.parse(args);
        const workflowResponse = await handleGetWorkflow({ id: input.id }, context);
        if (!workflowResponse.success) {
            return workflowResponse;
        }
        const workflow = workflowResponse.data;
        const validator = new workflow_validator_1.WorkflowValidator(repository, enhanced_config_validator_1.EnhancedConfigValidator);
        const validationResult = await validator.validateWorkflow(workflow, {
            validateNodes: true,
            validateConnections: true,
            validateExpressions: true,
            profile: 'ai-friendly'
        });
        const allFormatIssues = [];
        for (const node of workflow.nodes) {
            const formatContext = {
                nodeType: node.type,
                nodeName: node.name,
                nodeId: node.id
            };
            const nodeFormatIssues = expression_format_validator_1.ExpressionFormatValidator.validateNodeParameters(node.parameters, formatContext);
            const enrichedIssues = nodeFormatIssues.map(issue => ({
                ...issue,
                nodeName: node.name,
                nodeId: node.id
            }));
            allFormatIssues.push(...enrichedIssues);
        }
        const autoFixer = new workflow_auto_fixer_1.WorkflowAutoFixer(repository);
        const fixResult = autoFixer.generateFixes(workflow, validationResult, allFormatIssues, {
            applyFixes: input.applyFixes,
            fixTypes: input.fixTypes,
            confidenceThreshold: input.confidenceThreshold,
            maxFixes: input.maxFixes
        });
        if (fixResult.fixes.length === 0) {
            return {
                success: true,
                data: {
                    workflowId: workflow.id,
                    workflowName: workflow.name,
                    message: 'No automatic fixes available for this workflow',
                    validationSummary: {
                        errors: validationResult.errors.length,
                        warnings: validationResult.warnings.length
                    }
                }
            };
        }
        if (!input.applyFixes) {
            return {
                success: true,
                data: {
                    workflowId: workflow.id,
                    workflowName: workflow.name,
                    preview: true,
                    fixesAvailable: fixResult.fixes.length,
                    fixes: fixResult.fixes,
                    summary: fixResult.summary,
                    stats: fixResult.stats,
                    message: `${fixResult.fixes.length} fixes available. Set applyFixes=true to apply them.`
                }
            };
        }
        if (fixResult.operations.length > 0) {
            const updateResult = await (0, handlers_workflow_diff_1.handleUpdatePartialWorkflow)({
                id: workflow.id,
                operations: fixResult.operations
            }, context);
            if (!updateResult.success) {
                return {
                    success: false,
                    error: 'Failed to apply fixes',
                    details: {
                        fixes: fixResult.fixes,
                        updateError: updateResult.error
                    }
                };
            }
            return {
                success: true,
                data: {
                    workflowId: workflow.id,
                    workflowName: workflow.name,
                    fixesApplied: fixResult.fixes.length,
                    fixes: fixResult.fixes,
                    summary: fixResult.summary,
                    stats: fixResult.stats,
                    message: `Successfully applied ${fixResult.fixes.length} fixes to workflow "${workflow.name}"`
                }
            };
        }
        return {
            success: true,
            data: {
                workflowId: workflow.id,
                workflowName: workflow.name,
                message: 'No fixes needed'
            }
        };
    }
    catch (error) {
        if (error instanceof zod_1.z.ZodError) {
            return {
                success: false,
                error: 'Invalid input',
                details: { errors: error.errors }
            };
        }
        if (error instanceof n8n_errors_1.N8nApiError) {
            return {
                success: false,
                error: (0, n8n_errors_1.getUserFriendlyErrorMessage)(error),
                code: error.code
            };
        }
        return {
            success: false,
            error: error instanceof Error ? error.message : 'Unknown error occurred'
        };
    }
}
async function handleTriggerWebhookWorkflow(args, context) {
    try {
        const client = ensureApiConfigured(context);
        const input = triggerWebhookSchema.parse(args);
        const webhookRequest = {
            webhookUrl: input.webhookUrl,
            httpMethod: input.httpMethod || 'POST',
            data: input.data,
            headers: input.headers,
            waitForResponse: input.waitForResponse ?? true
        };
        const response = await client.triggerWebhook(webhookRequest);
        return {
            success: true,
            data: response,
            message: 'Webhook triggered successfully'
        };
    }
    catch (error) {
        if (error instanceof zod_1.z.ZodError) {
            return {
                success: false,
                error: 'Invalid input',
                details: { errors: error.errors }
            };
        }
        if (error instanceof n8n_errors_1.N8nApiError) {
            return {
                success: false,
                error: (0, n8n_errors_1.getUserFriendlyErrorMessage)(error),
                code: error.code,
                details: error.details
            };
        }
        return {
            success: false,
            error: error instanceof Error ? error.message : 'Unknown error occurred'
        };
    }
}
async function handleGetExecution(args, context) {
    try {
        const client = ensureApiConfigured(context);
        const { id, includeData } = zod_1.z.object({
            id: zod_1.z.string(),
            includeData: zod_1.z.boolean().optional()
        }).parse(args);
        const execution = await client.getExecution(id, includeData || false);
        return {
            success: true,
            data: execution
        };
    }
    catch (error) {
        if (error instanceof zod_1.z.ZodError) {
            return {
                success: false,
                error: 'Invalid input',
                details: { errors: error.errors }
            };
        }
        if (error instanceof n8n_errors_1.N8nApiError) {
            return {
                success: false,
                error: (0, n8n_errors_1.getUserFriendlyErrorMessage)(error),
                code: error.code
            };
        }
        return {
            success: false,
            error: error instanceof Error ? error.message : 'Unknown error occurred'
        };
    }
}
async function handleListExecutions(args, context) {
    try {
        const client = ensureApiConfigured(context);
        const input = listExecutionsSchema.parse(args || {});
        const response = await client.listExecutions({
            limit: input.limit || 100,
            cursor: input.cursor,
            workflowId: input.workflowId,
            projectId: input.projectId,
            status: input.status,
            includeData: input.includeData || false
        });
        return {
            success: true,
            data: {
                executions: response.data,
                returned: response.data.length,
                nextCursor: response.nextCursor,
                hasMore: !!response.nextCursor,
                ...(response.nextCursor ? {
                    _note: "More executions available. Use cursor to get next page."
                } : {})
            }
        };
    }
    catch (error) {
        if (error instanceof zod_1.z.ZodError) {
            return {
                success: false,
                error: 'Invalid input',
                details: { errors: error.errors }
            };
        }
        if (error instanceof n8n_errors_1.N8nApiError) {
            return {
                success: false,
                error: (0, n8n_errors_1.getUserFriendlyErrorMessage)(error),
                code: error.code
            };
        }
        return {
            success: false,
            error: error instanceof Error ? error.message : 'Unknown error occurred'
        };
    }
}
async function handleDeleteExecution(args, context) {
    try {
        const client = ensureApiConfigured(context);
        const { id } = zod_1.z.object({ id: zod_1.z.string() }).parse(args);
        await client.deleteExecution(id);
        return {
            success: true,
            message: `Execution ${id} deleted successfully`
        };
    }
    catch (error) {
        if (error instanceof zod_1.z.ZodError) {
            return {
                success: false,
                error: 'Invalid input',
                details: { errors: error.errors }
            };
        }
        if (error instanceof n8n_errors_1.N8nApiError) {
            return {
                success: false,
                error: (0, n8n_errors_1.getUserFriendlyErrorMessage)(error),
                code: error.code
            };
        }
        return {
            success: false,
            error: error instanceof Error ? error.message : 'Unknown error occurred'
        };
    }
}
async function handleHealthCheck(context) {
    try {
        const client = ensureApiConfigured(context);
        const health = await client.healthCheck();
        const packageJson = require('../../package.json');
        const mcpVersion = packageJson.version;
        const supportedN8nVersion = packageJson.dependencies?.n8n?.replace(/[^0-9.]/g, '');
        return {
            success: true,
            data: {
                status: health.status,
                instanceId: health.instanceId,
                n8nVersion: health.n8nVersion,
                features: health.features,
                apiUrl: (0, n8n_api_1.getN8nApiConfig)()?.baseUrl,
                mcpVersion,
                supportedN8nVersion,
                versionNote: 'AI Agent: Please inform the user to verify their n8n instance version matches or is compatible with the supported version listed above. The n8n API currently does not expose version information, so manual verification is required.'
            }
        };
    }
    catch (error) {
        if (error instanceof n8n_errors_1.N8nApiError) {
            return {
                success: false,
                error: (0, n8n_errors_1.getUserFriendlyErrorMessage)(error),
                code: error.code,
                details: {
                    apiUrl: (0, n8n_api_1.getN8nApiConfig)()?.baseUrl,
                    hint: 'Check if n8n is running and API is enabled'
                }
            };
        }
        return {
            success: false,
            error: error instanceof Error ? error.message : 'Unknown error occurred'
        };
    }
}
async function handleListAvailableTools(context) {
    const tools = [
        {
            category: 'Workflow Management',
            tools: [
                { name: 'n8n_create_workflow', description: 'Create new workflows' },
                { name: 'n8n_get_workflow', description: 'Get workflow by ID' },
                { name: 'n8n_get_workflow_details', description: 'Get detailed workflow info with stats' },
                { name: 'n8n_get_workflow_structure', description: 'Get simplified workflow structure' },
                { name: 'n8n_get_workflow_minimal', description: 'Get minimal workflow info' },
                { name: 'n8n_update_workflow', description: 'Update existing workflows' },
                { name: 'n8n_delete_workflow', description: 'Delete workflows' },
                { name: 'n8n_list_workflows', description: 'List workflows with filters' },
                { name: 'n8n_validate_workflow', description: 'Validate workflow from n8n instance' },
                { name: 'n8n_autofix_workflow', description: 'Automatically fix common workflow errors' }
            ]
        },
        {
            category: 'Execution Management',
            tools: [
                { name: 'n8n_trigger_webhook_workflow', description: 'Trigger workflows via webhook' },
                { name: 'n8n_get_execution', description: 'Get execution details' },
                { name: 'n8n_list_executions', description: 'List executions with filters' },
                { name: 'n8n_delete_execution', description: 'Delete execution records' }
            ]
        },
        {
            category: 'System',
            tools: [
                { name: 'n8n_health_check', description: 'Check API connectivity' },
                { name: 'n8n_list_available_tools', description: 'List all available tools' }
            ]
        }
    ];
    const config = (0, n8n_api_1.getN8nApiConfig)();
    const apiConfigured = config !== null;
    return {
        success: true,
        data: {
            tools,
            apiConfigured,
            configuration: config ? {
                apiUrl: config.baseUrl,
                timeout: config.timeout,
                maxRetries: config.maxRetries
            } : null,
            limitations: [
                'Cannot activate/deactivate workflows via API',
                'Cannot execute workflows directly (must use webhooks)',
                'Cannot stop running executions',
                'Tags and credentials have limited API support'
            ]
        }
    };
}
async function handleDiagnostic(request, context) {
    const verbose = request.params?.arguments?.verbose || false;
    const envVars = {
        N8N_API_URL: process.env.N8N_API_URL || null,
        N8N_API_KEY: process.env.N8N_API_KEY ? '***configured***' : null,
        NODE_ENV: process.env.NODE_ENV || 'production',
        MCP_MODE: process.env.MCP_MODE || 'stdio'
    };
    const apiConfig = (0, n8n_api_1.getN8nApiConfig)();
    const apiConfigured = apiConfig !== null;
    const apiClient = getN8nApiClient(context);
    let apiStatus = {
        configured: apiConfigured,
        connected: false,
        error: null,
        version: null
    };
    if (apiClient) {
        try {
            const health = await apiClient.healthCheck();
            apiStatus.connected = true;
            apiStatus.version = health.n8nVersion || 'unknown';
        }
        catch (error) {
            apiStatus.error = error instanceof Error ? error.message : 'Unknown error';
        }
    }
    const documentationTools = 22;
    const managementTools = apiConfigured ? 16 : 0;
    const totalTools = documentationTools + managementTools;
    const diagnostic = {
        timestamp: new Date().toISOString(),
        environment: envVars,
        apiConfiguration: {
            configured: apiConfigured,
            status: apiStatus,
            config: apiConfig ? {
                baseUrl: apiConfig.baseUrl,
                timeout: apiConfig.timeout,
                maxRetries: apiConfig.maxRetries
            } : null
        },
        toolsAvailability: {
            documentationTools: {
                count: documentationTools,
                enabled: true,
                description: 'Always available - node info, search, validation, etc.'
            },
            managementTools: {
                count: managementTools,
                enabled: apiConfigured,
                description: apiConfigured ?
                    'Management tools are ENABLED - create, update, execute workflows' :
                    'Management tools are DISABLED - configure N8N_API_URL and N8N_API_KEY to enable'
            },
            totalAvailable: totalTools
        },
        troubleshooting: {
            steps: apiConfigured ? [
                'API is configured and should work',
                'If tools are not showing in Claude Desktop:',
                '1. Restart Claude Desktop completely',
                '2. Check if using latest Docker image',
                '3. Verify environment variables are passed correctly',
                '4. Try running n8n_health_check to test connectivity'
            ] : [
                'To enable management tools:',
                '1. Set N8N_API_URL environment variable (e.g., https://your-n8n-instance.com)',
                '2. Set N8N_API_KEY environment variable (get from n8n API settings)',
                '3. Restart the MCP server',
                '4. Management tools will automatically appear'
            ],
            documentation: 'For detailed setup instructions, see: https://github.com/czlonkowski/n8n-mcp?tab=readme-ov-file#n8n-management-tools-optional---requires-api-configuration'
        }
    };
    if (verbose) {
        diagnostic['debug'] = {
            processEnv: Object.keys(process.env).filter(key => key.startsWith('N8N_') || key.startsWith('MCP_')),
            nodeVersion: process.version,
            platform: process.platform,
            workingDirectory: process.cwd()
        };
    }
    return {
        success: true,
        data: diagnostic
    };
}
//# sourceMappingURL=handlers-n8n-manager.js.map