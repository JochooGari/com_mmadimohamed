#!/usr/bin/env node
"use strict";
const fs = require('fs');
const path = require('path');
const { Readable, Writable } = require('stream');
const logFile = path.join(process.cwd(), 'ultra-minimal.log');
function log(message) {
    const timestamp = new Date().toISOString();
    fs.appendFileSync(logFile, `[${timestamp}] ${message}\n`);
}
log('ultra-minimal.ts started');
log(`Node version: ${process.version}`);
log(`Process argv: ${JSON.stringify(process.argv)}`);
log(`__dirname: ${__dirname}`);
log(`__filename: ${__filename}`);
log(`cwd: ${process.cwd()}`);
log(`env.MCP_MODE: ${process.env.MCP_MODE}`);
log(`env.EXTENSION_PATH: ${process.env.EXTENSION_PATH}`);
async function handleMessage(message) {
    log(`Received message: ${JSON.stringify(message)}`);
    if (message.method === 'initialize') {
        const response = {
            jsonrpc: '2.0',
            id: message.id,
            result: {
                protocolVersion: '2024-11-05',
                capabilities: {
                    tools: {}
                },
                serverInfo: {
                    name: 'ultra-minimal',
                    version: '1.0.0'
                }
            }
        };
        log(`Sending response: ${JSON.stringify(response)}`);
        process.stdout.write(JSON.stringify(response) + '\n');
    }
}
async function main() {
    log('Setting up stdio handler');
    let buffer = '';
    process.stdin.on('data', (chunk) => {
        buffer += chunk.toString();
        log(`Received data chunk, buffer length: ${buffer.length}`);
        let lines = buffer.split('\n');
        buffer = lines.pop() || '';
        for (const line of lines) {
            if (line.trim()) {
                try {
                    const message = JSON.parse(line);
                    handleMessage(message).catch(err => {
                        log(`Error handling message: ${err}`);
                    });
                }
                catch (err) {
                    log(`Error parsing JSON: ${err}, line: ${line}`);
                }
            }
        }
    });
    process.stdin.on('end', () => {
        log('stdin ended');
        process.exit(0);
    });
    process.on('SIGTERM', () => {
        log('Received SIGTERM');
        process.exit(0);
    });
    process.on('SIGINT', () => {
        log('Received SIGINT');
        process.exit(0);
    });
    setInterval(() => {
        log('Still alive...');
    }, 30000);
    log('Ready and waiting for input');
}
process.on('uncaughtException', (error) => {
    log(`Uncaught exception: ${error}`);
    log(`Stack: ${error.stack}`);
    process.exit(1);
});
process.on('unhandledRejection', (reason, promise) => {
    log(`Unhandled rejection at: ${promise}, reason: ${reason}`);
    process.exit(1);
});
log('About to call main()');
main().catch(err => {
    log(`Fatal error in main: ${err}`);
    process.exit(1);
});
//# sourceMappingURL=ultra-minimal.js.map