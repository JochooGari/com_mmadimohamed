#!/usr/bin/env node
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchTemplates = fetchTemplates;
const database_adapter_1 = require("../database/database-adapter");
const template_service_1 = require("../templates/template-service");
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const zlib = __importStar(require("zlib"));
const dotenv = __importStar(require("dotenv"));
dotenv.config();
async function fetchTemplates(mode = 'rebuild', generateMetadata = false, metadataOnly = false) {
    if (metadataOnly) {
        console.log('ðŸ¤– Metadata-only mode: Generating metadata for existing templates...\n');
        if (!process.env.OPENAI_API_KEY) {
            console.error('âŒ OPENAI_API_KEY not set in environment');
            process.exit(1);
        }
        const db = await (0, database_adapter_1.createDatabaseAdapter)('./data/nodes.db');
        const service = new template_service_1.TemplateService(db);
        await generateTemplateMetadata(db, service);
        if ('close' in db && typeof db.close === 'function') {
            db.close();
        }
        return;
    }
    const modeEmoji = mode === 'rebuild' ? 'ðŸ”„' : 'â¬†ï¸';
    const modeText = mode === 'rebuild' ? 'Rebuilding' : 'Updating';
    console.log(`${modeEmoji} ${modeText} n8n workflow templates...\n`);
    if (generateMetadata) {
        console.log('ðŸ¤– Metadata generation enabled (using OpenAI)\n');
    }
    const dataDir = './data';
    if (!fs.existsSync(dataDir)) {
        fs.mkdirSync(dataDir, { recursive: true });
    }
    const db = await (0, database_adapter_1.createDatabaseAdapter)('./data/nodes.db');
    if (mode === 'rebuild') {
        try {
            db.exec('DROP TABLE IF EXISTS templates');
            db.exec('DROP TABLE IF EXISTS templates_fts');
            console.log('ðŸ—‘ï¸  Dropped existing templates tables (rebuild mode)\n');
            const schema = fs.readFileSync(path.join(__dirname, '../../src/database/schema.sql'), 'utf8');
            db.exec(schema);
            console.log('ðŸ“‹ Applied database schema\n');
        }
        catch (error) {
            console.error('âŒ Error setting up database schema:', error);
            throw error;
        }
    }
    else {
        console.log('ðŸ“Š Update mode: Keeping existing templates and schema\n');
        try {
            const columns = db.prepare("PRAGMA table_info(templates)").all();
            const hasMetadataColumn = columns.some((col) => col.name === 'metadata_json');
            if (!hasMetadataColumn) {
                console.log('ðŸ“‹ Adding metadata columns to existing schema...');
                db.exec(`
          ALTER TABLE templates ADD COLUMN metadata_json TEXT;
          ALTER TABLE templates ADD COLUMN metadata_generated_at DATETIME;
        `);
                console.log('âœ… Metadata columns added\n');
            }
        }
        catch (error) {
            console.log('ðŸ“‹ Schema is up to date\n');
        }
    }
    const service = new template_service_1.TemplateService(db);
    let lastMessage = '';
    const startTime = Date.now();
    try {
        await service.fetchAndUpdateTemplates((message, current, total) => {
            if (lastMessage) {
                process.stdout.write('\r' + ' '.repeat(lastMessage.length) + '\r');
            }
            const progress = total > 0 ? Math.round((current / total) * 100) : 0;
            lastMessage = `ðŸ“Š ${message}: ${current}/${total} (${progress}%)`;
            process.stdout.write(lastMessage);
        }, mode);
        console.log('\n');
        const stats = await service.getTemplateStats();
        const elapsed = Math.round((Date.now() - startTime) / 1000);
        console.log('âœ… Template fetch complete!\n');
        console.log('ðŸ“ˆ Statistics:');
        console.log(`   - Total templates: ${stats.totalTemplates}`);
        console.log(`   - Average views: ${stats.averageViews}`);
        console.log(`   - Time elapsed: ${elapsed} seconds`);
        console.log('\nðŸ” Top used nodes:');
        stats.topUsedNodes.forEach((node, index) => {
            console.log(`   ${index + 1}. ${node.node} (${node.count} templates)`);
        });
        if (generateMetadata && process.env.OPENAI_API_KEY) {
            console.log('\nðŸ¤– Generating metadata for templates...');
            await generateTemplateMetadata(db, service);
        }
        else if (generateMetadata && !process.env.OPENAI_API_KEY) {
            console.log('\nâš ï¸  Metadata generation requested but OPENAI_API_KEY not set');
        }
    }
    catch (error) {
        console.error('\nâŒ Error fetching templates:', error);
        process.exit(1);
    }
    if ('close' in db && typeof db.close === 'function') {
        db.close();
    }
}
async function generateTemplateMetadata(db, service) {
    try {
        const { BatchProcessor } = await Promise.resolve().then(() => __importStar(require('../templates/batch-processor')));
        const repository = service.repository;
        const limit = parseInt(process.env.METADATA_LIMIT || '0');
        const templatesWithoutMetadata = limit > 0
            ? repository.getTemplatesWithoutMetadata(limit)
            : repository.getTemplatesWithoutMetadata(999999);
        if (templatesWithoutMetadata.length === 0) {
            console.log('âœ… All templates already have metadata');
            return;
        }
        console.log(`Found ${templatesWithoutMetadata.length} templates without metadata`);
        const batchSize = parseInt(process.env.OPENAI_BATCH_SIZE || '50');
        console.log(`Processing in batches of ${batchSize} templates each`);
        if (batchSize > 100) {
            console.log(`âš ï¸  Large batch size (${batchSize}) may take longer to process`);
            console.log(`   Consider using OPENAI_BATCH_SIZE=50 for faster results`);
        }
        const processor = new BatchProcessor({
            apiKey: process.env.OPENAI_API_KEY,
            model: process.env.OPENAI_MODEL || 'gpt-4o-mini',
            batchSize: batchSize,
            outputDir: './temp/batch'
        });
        const requests = templatesWithoutMetadata.map((t) => {
            let workflow = undefined;
            try {
                if (t.workflow_json_compressed) {
                    const decompressed = zlib.gunzipSync(Buffer.from(t.workflow_json_compressed, 'base64'));
                    workflow = JSON.parse(decompressed.toString());
                }
                else if (t.workflow_json) {
                    workflow = JSON.parse(t.workflow_json);
                }
            }
            catch (error) {
                console.warn(`Failed to parse workflow for template ${t.id}:`, error);
            }
            return {
                templateId: t.id,
                name: t.name,
                description: t.description,
                nodes: JSON.parse(t.nodes_used),
                workflow
            };
        });
        const results = await processor.processTemplates(requests, (message, current, total) => {
            process.stdout.write(`\rðŸ“Š ${message}: ${current}/${total}`);
        });
        console.log('\n');
        const metadataMap = new Map();
        for (const [templateId, result] of results) {
            if (!result.error) {
                metadataMap.set(templateId, result.metadata);
            }
        }
        if (metadataMap.size > 0) {
            repository.batchUpdateMetadata(metadataMap);
            console.log(`âœ… Updated metadata for ${metadataMap.size} templates`);
        }
        const stats = repository.getMetadataStats();
        console.log('\nðŸ“ˆ Metadata Statistics:');
        console.log(`   - Total templates: ${stats.total}`);
        console.log(`   - With metadata: ${stats.withMetadata}`);
        console.log(`   - Without metadata: ${stats.withoutMetadata}`);
        console.log(`   - Outdated (>30 days): ${stats.outdated}`);
    }
    catch (error) {
        console.error('\nâŒ Error generating metadata:', error);
    }
}
function parseArgs() {
    const args = process.argv.slice(2);
    let mode = 'rebuild';
    let generateMetadata = false;
    let metadataOnly = false;
    const modeIndex = args.findIndex(arg => arg.startsWith('--mode'));
    if (modeIndex !== -1) {
        const modeArg = args[modeIndex];
        const modeValue = modeArg.includes('=') ? modeArg.split('=')[1] : args[modeIndex + 1];
        if (modeValue === 'update') {
            mode = 'update';
        }
    }
    if (args.includes('--update')) {
        mode = 'update';
    }
    if (args.includes('--generate-metadata') || args.includes('--metadata')) {
        generateMetadata = true;
    }
    if (args.includes('--metadata-only')) {
        metadataOnly = true;
    }
    if (args.includes('--help') || args.includes('-h')) {
        console.log('Usage: npm run fetch:templates [options]\n');
        console.log('Options:');
        console.log('  --mode=rebuild|update  Rebuild from scratch or update existing (default: rebuild)');
        console.log('  --update               Shorthand for --mode=update');
        console.log('  --generate-metadata    Generate AI metadata after fetching templates');
        console.log('  --metadata             Shorthand for --generate-metadata');
        console.log('  --metadata-only        Only generate metadata, skip template fetching');
        console.log('  --help, -h             Show this help message');
        process.exit(0);
    }
    return { mode, generateMetadata, metadataOnly };
}
if (require.main === module) {
    const { mode, generateMetadata, metadataOnly } = parseArgs();
    fetchTemplates(mode, generateMetadata, metadataOnly).catch(console.error);
}
//# sourceMappingURL=fetch-templates.js.map