"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const mcp_engine_1 = require("../mcp-engine");
const logger_1 = require("../utils/logger");
const logger = new logger_1.Logger({ prefix: '[ValidationParity]' });
async function testValidationParity() {
    const engine = new mcp_engine_1.N8NMCPEngine();
    await engine.initialize();
    const testWorkflow = {
        name: 'Test Validation Parity',
        nodes: [
            {
                id: 'webhook_1',
                name: 'Webhook',
                type: 'n8n-nodes-base.webhook',
                typeVersion: 1.1,
                position: [250, 300],
                parameters: {
                    httpMethod: 'GET',
                    path: 'test-webhook',
                    responseMode: 'onReceived',
                    responseData: 'firstEntryJson'
                }
            },
            {
                id: 'http_1',
                name: 'HTTP Request',
                type: 'n8n-nodes-base.httpRequest',
                typeVersion: 5.0,
                position: [450, 300],
                parameters: {
                    method: 'GET',
                    url: '{{ $json.webhookUrl }}',
                    sendHeaders: true,
                    headerParameters: {
                        parameters: [
                            {
                                name: 'Authorization',
                                value: '{{ $json.token }}'
                            }
                        ]
                    }
                },
                onError: 'continueErrorOutput'
            },
            {
                id: 'respond_1',
                name: 'Respond to Webhook',
                type: 'n8n-nodes-base.respondToWebhook',
                typeVersion: 1.1,
                position: [650, 300],
                parameters: {
                    respondWith: 'json',
                    responseBody: '={{ $json }}'
                }
            }
        ],
        connections: {
            'Webhook': {
                main: [
                    [
                        {
                            node: 'HTTP Request',
                            type: 'main',
                            index: 0
                        }
                    ]
                ]
            },
            'HTTP Request': {
                main: [
                    [
                        {
                            node: 'Respond to Webhook',
                            type: 'main',
                            index: 0
                        }
                    ]
                ]
            }
        }
    };
    logger.info('Testing validate_workflow tool...');
    const baseValidation = await engine.callTool('validate_workflow', {
        workflow: testWorkflow
    });
    logger.info('Base validation result:', {
        valid: baseValidation.valid,
        errorCount: baseValidation.summary?.errorCount || 0,
        warningCount: baseValidation.summary?.warningCount || 0
    });
    if (baseValidation.errors?.length > 0) {
        logger.info('Errors found in validate_workflow:');
        for (const error of baseValidation.errors) {
            if (error.message.includes('missing prefix') ||
                error.message.includes('expression format') ||
                error.message.includes('onError') ||
                error.message.includes('error output')) {
                logger.info(`âœ“ Found expected error: ${error.message.substring(0, 100)}...`);
            }
        }
    }
    if (baseValidation.warnings?.length > 0) {
        logger.info('Warnings found in validate_workflow:');
        for (const warning of baseValidation.warnings) {
            if (warning.message.includes('missing prefix') ||
                warning.message.includes('expression format')) {
                logger.info(`âœ“ Found expected warning: ${warning.message.substring(0, 100)}...`);
            }
        }
    }
    const capabilities = {
        detectsMissingExpressionPrefix: false,
        detectsErrorOutputMismatch: false,
        detectsIncorrectErrorConfig: false
    };
    const allMessages = [
        ...(baseValidation.errors || []).map((e) => e.message),
        ...(baseValidation.warnings || []).map((w) => w.message)
    ];
    for (const message of allMessages) {
        if (message.includes('missing prefix') || message.includes('expression format')) {
            capabilities.detectsMissingExpressionPrefix = true;
        }
        if (message.includes('onError') && message.includes('error output')) {
            capabilities.detectsErrorOutputMismatch = true;
        }
        if (message.includes('error output configuration')) {
            capabilities.detectsIncorrectErrorConfig = true;
        }
    }
    logger.info('\nValidation Capabilities Detected:', capabilities);
    const allCapabilitiesPresent = Object.values(capabilities).every(cap => cap === true);
    if (allCapabilitiesPresent) {
        logger.info('\nâœ… All validation capabilities are present in validate_workflow!');
    }
    else {
        logger.error('\nâŒ Some validation capabilities are missing:');
        for (const [key, value] of Object.entries(capabilities)) {
            if (!value) {
                logger.error(`  - ${key}`);
            }
        }
    }
    logger.info('\nðŸ“ Note: n8n_validate_workflow uses the same WorkflowValidator class');
    logger.info('   and EnhancedConfigValidator, so it has identical capabilities.');
    await engine.shutdown();
}
testValidationParity().catch(error => {
    logger.error('Test failed:', error);
    process.exit(1);
});
//# sourceMappingURL=test-validation-parity.js.map