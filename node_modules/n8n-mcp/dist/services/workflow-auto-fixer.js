"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkflowAutoFixer = void 0;
exports.isNodeFormatIssue = isNodeFormatIssue;
const crypto_1 = __importDefault(require("crypto"));
const node_similarity_service_1 = require("./node-similarity-service");
const logger_1 = require("../utils/logger");
const logger = new logger_1.Logger({ prefix: '[WorkflowAutoFixer]' });
function isNodeFormatIssue(issue) {
    return 'nodeName' in issue && 'nodeId' in issue &&
        typeof issue.nodeName === 'string' &&
        typeof issue.nodeId === 'string';
}
class WorkflowAutoFixer {
    constructor(repository) {
        this.defaultConfig = {
            applyFixes: false,
            confidenceThreshold: 'medium',
            maxFixes: 50
        };
        this.similarityService = null;
        if (repository) {
            this.similarityService = new node_similarity_service_1.NodeSimilarityService(repository);
        }
    }
    generateFixes(workflow, validationResult, formatIssues = [], config = {}) {
        const fullConfig = { ...this.defaultConfig, ...config };
        const operations = [];
        const fixes = [];
        const nodeMap = new Map();
        workflow.nodes.forEach(node => {
            nodeMap.set(node.name, node);
            nodeMap.set(node.id, node);
        });
        if (!fullConfig.fixTypes || fullConfig.fixTypes.includes('expression-format')) {
            this.processExpressionFormatFixes(formatIssues, nodeMap, operations, fixes);
        }
        if (!fullConfig.fixTypes || fullConfig.fixTypes.includes('typeversion-correction')) {
            this.processTypeVersionFixes(validationResult, nodeMap, operations, fixes);
        }
        if (!fullConfig.fixTypes || fullConfig.fixTypes.includes('error-output-config')) {
            this.processErrorOutputFixes(validationResult, nodeMap, workflow, operations, fixes);
        }
        if (!fullConfig.fixTypes || fullConfig.fixTypes.includes('node-type-correction')) {
            this.processNodeTypeFixes(validationResult, nodeMap, operations, fixes);
        }
        if (!fullConfig.fixTypes || fullConfig.fixTypes.includes('webhook-missing-path')) {
            this.processWebhookPathFixes(validationResult, nodeMap, operations, fixes);
        }
        const filteredFixes = this.filterByConfidence(fixes, fullConfig.confidenceThreshold);
        const filteredOperations = this.filterOperationsByFixes(operations, filteredFixes, fixes);
        const limitedFixes = filteredFixes.slice(0, fullConfig.maxFixes);
        const limitedOperations = this.filterOperationsByFixes(filteredOperations, limitedFixes, filteredFixes);
        const stats = this.calculateStats(limitedFixes);
        const summary = this.generateSummary(stats);
        return {
            operations: limitedOperations,
            fixes: limitedFixes,
            summary,
            stats
        };
    }
    processExpressionFormatFixes(formatIssues, nodeMap, operations, fixes) {
        const fixesByNode = new Map();
        for (const issue of formatIssues) {
            if (issue.issueType === 'missing-prefix') {
                if (!isNodeFormatIssue(issue)) {
                    logger.warn('Expression format issue missing node information', {
                        fieldPath: issue.fieldPath,
                        issueType: issue.issueType
                    });
                    continue;
                }
                const nodeName = issue.nodeName;
                if (!fixesByNode.has(nodeName)) {
                    fixesByNode.set(nodeName, []);
                }
                fixesByNode.get(nodeName).push(issue);
            }
        }
        for (const [nodeName, nodeIssues] of fixesByNode) {
            const node = nodeMap.get(nodeName);
            if (!node)
                continue;
            const updatedParameters = JSON.parse(JSON.stringify(node.parameters || {}));
            for (const issue of nodeIssues) {
                const fieldPath = issue.fieldPath.split('.');
                this.setNestedValue(updatedParameters, fieldPath, issue.correctedValue);
                fixes.push({
                    node: nodeName,
                    field: issue.fieldPath,
                    type: 'expression-format',
                    before: issue.currentValue,
                    after: issue.correctedValue,
                    confidence: 'high',
                    description: issue.explanation
                });
            }
            const operation = {
                type: 'updateNode',
                nodeId: nodeName,
                updates: {
                    parameters: updatedParameters
                }
            };
            operations.push(operation);
        }
    }
    processTypeVersionFixes(validationResult, nodeMap, operations, fixes) {
        for (const error of validationResult.errors) {
            if (error.message.includes('typeVersion') && error.message.includes('exceeds maximum')) {
                const versionMatch = error.message.match(/typeVersion (\d+(?:\.\d+)?) exceeds maximum supported version (\d+(?:\.\d+)?)/);
                if (versionMatch) {
                    const currentVersion = parseFloat(versionMatch[1]);
                    const maxVersion = parseFloat(versionMatch[2]);
                    const nodeName = error.nodeName || error.nodeId;
                    if (!nodeName)
                        continue;
                    const node = nodeMap.get(nodeName);
                    if (!node)
                        continue;
                    fixes.push({
                        node: nodeName,
                        field: 'typeVersion',
                        type: 'typeversion-correction',
                        before: currentVersion,
                        after: maxVersion,
                        confidence: 'medium',
                        description: `Corrected typeVersion from ${currentVersion} to maximum supported ${maxVersion}`
                    });
                    const operation = {
                        type: 'updateNode',
                        nodeId: nodeName,
                        updates: {
                            typeVersion: maxVersion
                        }
                    };
                    operations.push(operation);
                }
            }
        }
    }
    processErrorOutputFixes(validationResult, nodeMap, workflow, operations, fixes) {
        for (const error of validationResult.errors) {
            if (error.message.includes('onError: \'continueErrorOutput\'') &&
                error.message.includes('no error output connections')) {
                const nodeName = error.nodeName || error.nodeId;
                if (!nodeName)
                    continue;
                const node = nodeMap.get(nodeName);
                if (!node)
                    continue;
                fixes.push({
                    node: nodeName,
                    field: 'onError',
                    type: 'error-output-config',
                    before: 'continueErrorOutput',
                    after: undefined,
                    confidence: 'medium',
                    description: 'Removed onError setting due to missing error output connections'
                });
                const operation = {
                    type: 'updateNode',
                    nodeId: nodeName,
                    updates: {
                        onError: undefined
                    }
                };
                operations.push(operation);
            }
        }
    }
    processNodeTypeFixes(validationResult, nodeMap, operations, fixes) {
        if (!this.similarityService) {
            return;
        }
        for (const error of validationResult.errors) {
            const nodeError = error;
            if (error.message?.includes('Unknown node type:') && nodeError.suggestions) {
                const highConfidenceSuggestion = nodeError.suggestions.find(s => s.confidence >= 0.9);
                if (highConfidenceSuggestion && nodeError.nodeId) {
                    const node = nodeMap.get(nodeError.nodeId) || nodeMap.get(nodeError.nodeName || '');
                    if (node) {
                        fixes.push({
                            node: node.name,
                            field: 'type',
                            type: 'node-type-correction',
                            before: node.type,
                            after: highConfidenceSuggestion.nodeType,
                            confidence: 'high',
                            description: `Fix node type: "${node.type}" â†’ "${highConfidenceSuggestion.nodeType}" (${highConfidenceSuggestion.reason})`
                        });
                        const operation = {
                            type: 'updateNode',
                            nodeId: node.name,
                            updates: {
                                type: highConfidenceSuggestion.nodeType
                            }
                        };
                        operations.push(operation);
                    }
                }
            }
        }
    }
    processWebhookPathFixes(validationResult, nodeMap, operations, fixes) {
        for (const error of validationResult.errors) {
            if (error.message === 'Webhook path is required') {
                const nodeName = error.nodeName || error.nodeId;
                if (!nodeName)
                    continue;
                const node = nodeMap.get(nodeName);
                if (!node)
                    continue;
                if (!node.type?.includes('webhook'))
                    continue;
                const webhookId = crypto_1.default.randomUUID();
                const currentTypeVersion = node.typeVersion || 1;
                const needsVersionUpdate = currentTypeVersion < 2.1;
                fixes.push({
                    node: nodeName,
                    field: 'path',
                    type: 'webhook-missing-path',
                    before: undefined,
                    after: webhookId,
                    confidence: 'high',
                    description: needsVersionUpdate
                        ? `Generated webhook path and ID: ${webhookId} (also updating typeVersion to 2.1)`
                        : `Generated webhook path and ID: ${webhookId}`
                });
                const updates = {
                    'parameters.path': webhookId,
                    'webhookId': webhookId
                };
                if (needsVersionUpdate) {
                    updates['typeVersion'] = 2.1;
                }
                const operation = {
                    type: 'updateNode',
                    nodeId: nodeName,
                    updates
                };
                operations.push(operation);
            }
        }
    }
    setNestedValue(obj, path, value) {
        if (!obj || typeof obj !== 'object') {
            throw new Error('Cannot set value on non-object');
        }
        if (path.length === 0) {
            throw new Error('Cannot set value with empty path');
        }
        try {
            let current = obj;
            for (let i = 0; i < path.length - 1; i++) {
                const key = path[i];
                if (key.includes('[')) {
                    const matches = key.match(/^([^[]+)\[(\d+)\]$/);
                    if (!matches) {
                        throw new Error(`Invalid array notation: ${key}`);
                    }
                    const [, arrayKey, indexStr] = matches;
                    const index = parseInt(indexStr, 10);
                    if (isNaN(index) || index < 0) {
                        throw new Error(`Invalid array index: ${indexStr}`);
                    }
                    if (!current[arrayKey]) {
                        current[arrayKey] = [];
                    }
                    if (!Array.isArray(current[arrayKey])) {
                        throw new Error(`Expected array at ${arrayKey}, got ${typeof current[arrayKey]}`);
                    }
                    while (current[arrayKey].length <= index) {
                        current[arrayKey].push({});
                    }
                    current = current[arrayKey][index];
                }
                else {
                    if (current[key] === null || current[key] === undefined) {
                        current[key] = {};
                    }
                    if (typeof current[key] !== 'object' || Array.isArray(current[key])) {
                        throw new Error(`Cannot traverse through ${typeof current[key]} at ${key}`);
                    }
                    current = current[key];
                }
            }
            const lastKey = path[path.length - 1];
            if (lastKey.includes('[')) {
                const matches = lastKey.match(/^([^[]+)\[(\d+)\]$/);
                if (!matches) {
                    throw new Error(`Invalid array notation: ${lastKey}`);
                }
                const [, arrayKey, indexStr] = matches;
                const index = parseInt(indexStr, 10);
                if (isNaN(index) || index < 0) {
                    throw new Error(`Invalid array index: ${indexStr}`);
                }
                if (!current[arrayKey]) {
                    current[arrayKey] = [];
                }
                if (!Array.isArray(current[arrayKey])) {
                    throw new Error(`Expected array at ${arrayKey}, got ${typeof current[arrayKey]}`);
                }
                while (current[arrayKey].length <= index) {
                    current[arrayKey].push(null);
                }
                current[arrayKey][index] = value;
            }
            else {
                current[lastKey] = value;
            }
        }
        catch (error) {
            logger.error('Failed to set nested value', {
                path: path.join('.'),
                error: error instanceof Error ? error.message : String(error)
            });
            throw error;
        }
    }
    filterByConfidence(fixes, threshold) {
        if (!threshold)
            return fixes;
        const levels = ['high', 'medium', 'low'];
        const thresholdIndex = levels.indexOf(threshold);
        return fixes.filter(fix => {
            const fixIndex = levels.indexOf(fix.confidence);
            return fixIndex <= thresholdIndex;
        });
    }
    filterOperationsByFixes(operations, filteredFixes, allFixes) {
        const fixedNodes = new Set(filteredFixes.map(f => f.node));
        return operations.filter(op => {
            if (op.type === 'updateNode') {
                return fixedNodes.has(op.nodeId || '');
            }
            return true;
        });
    }
    calculateStats(fixes) {
        const stats = {
            total: fixes.length,
            byType: {
                'expression-format': 0,
                'typeversion-correction': 0,
                'error-output-config': 0,
                'node-type-correction': 0,
                'webhook-missing-path': 0
            },
            byConfidence: {
                'high': 0,
                'medium': 0,
                'low': 0
            }
        };
        for (const fix of fixes) {
            stats.byType[fix.type]++;
            stats.byConfidence[fix.confidence]++;
        }
        return stats;
    }
    generateSummary(stats) {
        if (stats.total === 0) {
            return 'No fixes available';
        }
        const parts = [];
        if (stats.byType['expression-format'] > 0) {
            parts.push(`${stats.byType['expression-format']} expression format ${stats.byType['expression-format'] === 1 ? 'error' : 'errors'}`);
        }
        if (stats.byType['typeversion-correction'] > 0) {
            parts.push(`${stats.byType['typeversion-correction']} version ${stats.byType['typeversion-correction'] === 1 ? 'issue' : 'issues'}`);
        }
        if (stats.byType['error-output-config'] > 0) {
            parts.push(`${stats.byType['error-output-config']} error output ${stats.byType['error-output-config'] === 1 ? 'configuration' : 'configurations'}`);
        }
        if (stats.byType['node-type-correction'] > 0) {
            parts.push(`${stats.byType['node-type-correction']} node type ${stats.byType['node-type-correction'] === 1 ? 'correction' : 'corrections'}`);
        }
        if (stats.byType['webhook-missing-path'] > 0) {
            parts.push(`${stats.byType['webhook-missing-path']} webhook ${stats.byType['webhook-missing-path'] === 1 ? 'path' : 'paths'}`);
        }
        if (parts.length === 0) {
            return `Fixed ${stats.total} ${stats.total === 1 ? 'issue' : 'issues'}`;
        }
        return `Fixed ${parts.join(', ')}`;
    }
}
exports.WorkflowAutoFixer = WorkflowAutoFixer;
//# sourceMappingURL=workflow-auto-fixer.js.map