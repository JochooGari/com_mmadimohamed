"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkflowOwnershipService = void 0;
const logger_1 = require("../utils/logger");
const cache_utils_1 = require("../utils/cache-utils");
class WorkflowOwnershipService {
    constructor(apiClient) {
        this.apiClient = apiClient;
        this.ownershipCache = new Map();
        this.CACHE_TTL = 5 * 60 * 1000;
        this.INSTANCE_TAG_PREFIX = 'mcp-instance:';
        this.MAX_CACHE_SIZE = 10000;
    }
    setApiClient(client) {
        this.apiClient = client;
    }
    getInstanceIdentifier(context) {
        if (context.instanceId) {
            return context.instanceId;
        }
        return (0, cache_utils_1.createCacheKey)(`${context.n8nApiUrl}:${context.n8nApiKey}`).substring(0, 16);
    }
    getInstanceTag(context) {
        return `${this.INSTANCE_TAG_PREFIX}${this.getInstanceIdentifier(context)}`;
    }
    extractInstanceFromTags(tags) {
        if (!tags || tags.length === 0)
            return null;
        const instanceTag = tags.find(tag => tag.startsWith(this.INSTANCE_TAG_PREFIX));
        if (!instanceTag)
            return null;
        return instanceTag.replace(this.INSTANCE_TAG_PREFIX, '');
    }
    async validateAccess(workflowId, context) {
        if (!context?.n8nApiUrl || !context?.n8nApiKey) {
            logger_1.logger.debug('No instance context provided, allowing access for backward compatibility');
            return true;
        }
        const instanceId = this.getInstanceIdentifier(context);
        const cached = this.ownershipCache.get(workflowId);
        if (cached && this.isCacheValid(cached)) {
            const hasAccess = cached.instanceId === instanceId;
            logger_1.logger.debug('Workflow ownership cache hit', {
                workflowId,
                instanceId,
                cachedOwner: cached.instanceId,
                hasAccess
            });
            return hasAccess;
        }
        logger_1.logger.debug('Workflow ownership cache miss, verifying ownership', {
            workflowId,
            instanceId
        });
        try {
            if (!this.apiClient) {
                logger_1.logger.warn('No API client available for ownership verification');
                return true;
            }
            const workflow = await this.apiClient.getWorkflow(workflowId);
            const workflowInstanceId = this.extractInstanceFromTags(workflow.tags);
            if (workflowInstanceId === null) {
                logger_1.logger.info('Workflow has no instance tag, treating as unclaimed', {
                    workflowId,
                    workflowName: workflow.name
                });
                await this.claimWorkflow(workflowId, workflow, context);
                return true;
            }
            this.updateOwnershipCache(workflowId, workflowInstanceId, context.n8nApiUrl || '');
            const hasAccess = workflowInstanceId === instanceId;
            if (!hasAccess) {
                logger_1.logger.warn('Access denied: workflow belongs to different instance', {
                    workflowId,
                    requestingInstance: instanceId,
                    owningInstance: workflowInstanceId
                });
            }
            return hasAccess;
        }
        catch (error) {
            logger_1.logger.error('Error validating workflow ownership', {
                workflowId,
                instanceId,
                error: error instanceof Error ? error.message : String(error)
            });
            return false;
        }
    }
    async trackOwnership(workflowId, context) {
        if (!context?.n8nApiUrl || !context?.n8nApiKey) {
            logger_1.logger.debug('No instance context for ownership tracking');
            return;
        }
        const instanceId = this.getInstanceIdentifier(context);
        const instanceTag = this.getInstanceTag(context);
        try {
            if (this.apiClient) {
                const workflow = await this.apiClient.getWorkflow(workflowId);
                const tags = workflow.tags || [];
                if (!tags.some(tag => tag.startsWith(this.INSTANCE_TAG_PREFIX))) {
                    tags.push(instanceTag);
                    await this.apiClient.updateWorkflow(workflowId, { tags });
                    logger_1.logger.info('Added instance ownership tag to workflow', {
                        workflowId,
                        instanceId,
                        instanceTag
                    });
                }
            }
            this.updateOwnershipCache(workflowId, instanceId, context.n8nApiUrl);
        }
        catch (error) {
            logger_1.logger.error('Error tracking workflow ownership', {
                workflowId,
                instanceId,
                error: error instanceof Error ? error.message : String(error)
            });
        }
    }
    async claimWorkflow(workflowId, workflow, context) {
        if (!this.apiClient)
            return;
        const instanceTag = this.getInstanceTag(context);
        const tags = workflow.tags || [];
        tags.push(instanceTag);
        try {
            await this.apiClient.updateWorkflow(workflowId, { tags });
            logger_1.logger.info('Claimed unclaimed workflow for instance', {
                workflowId,
                workflowName: workflow.name,
                instanceId: this.getInstanceIdentifier(context)
            });
            this.updateOwnershipCache(workflowId, this.getInstanceIdentifier(context), context.n8nApiUrl || '');
        }
        catch (error) {
            logger_1.logger.error('Error claiming workflow', {
                workflowId,
                error: error instanceof Error ? error.message : String(error)
            });
        }
    }
    async filterWorkflowsByInstance(workflows, context) {
        if (!context?.n8nApiUrl || !context?.n8nApiKey) {
            return workflows;
        }
        const instanceId = this.getInstanceIdentifier(context);
        return workflows.filter(workflow => {
            const workflowInstanceId = this.extractInstanceFromTags(workflow.tags);
            if (workflowInstanceId === null) {
                logger_1.logger.debug('Including unclaimed workflow in list', {
                    workflowId: workflow.id,
                    workflowName: workflow.name
                });
                return true;
            }
            return workflowInstanceId === instanceId;
        });
    }
    updateOwnershipCache(workflowId, instanceId, instanceUrl) {
        if (this.ownershipCache.size >= this.MAX_CACHE_SIZE) {
            const entriesToRemove = Math.floor(this.MAX_CACHE_SIZE * 0.1);
            const keys = Array.from(this.ownershipCache.keys()).slice(0, entriesToRemove);
            keys.forEach(key => this.ownershipCache.delete(key));
            logger_1.logger.debug('Evicted ownership cache entries', {
                evicted: entriesToRemove,
                remaining: this.ownershipCache.size
            });
        }
        this.ownershipCache.set(workflowId, {
            workflowId,
            instanceId,
            instanceUrl,
            createdAt: new Date(),
            lastVerified: new Date()
        });
    }
    isCacheValid(entry) {
        const age = Date.now() - entry.lastVerified.getTime();
        return age < this.CACHE_TTL;
    }
    clearCache() {
        this.ownershipCache.clear();
        logger_1.logger.debug('Cleared workflow ownership cache');
    }
    getCacheStats() {
        return {
            size: this.ownershipCache.size,
            maxSize: this.MAX_CACHE_SIZE,
            ttl: this.CACHE_TTL
        };
    }
}
exports.WorkflowOwnershipService = WorkflowOwnershipService;
//# sourceMappingURL=workflow-ownership.js.map